use crate::term::{self, Term, Sym, BTerm, Param};
use crate::decl::{self, Decl, Constructor};
use crate::token::{Token};

grammar<'input>;

Ident: Sym = <s:"ident"> => Sym::from(s);

extern {
    enum Token<'input> {
        "ident" => Token::Ident(<&'input str>),
        "universe" => Token::Universe(<&'input str>),
        "forall" => Token::Pi,
        "exists" => Token::Sigma,
        "data" => Token::Data,
        "codata" => Token::Codata,

        "@" => Token::At,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "=>" => Token::DArrow,
        ":=" => Token::Assignment,
        "lam" => Token::Lam,
        "let" => Token::Let,
        "|" => Token::Pipe,
        "->" => Token::RArrow,

        "{" => Token::LBrace,
        "[" => Token::LBracket,
        "(" => Token::LParen,

        "}" => Token::RBrace,
        "]" => Token::RBracket,
        ")" => Token::RParen,
    }
}

AtomExpr: Term = {
    <uni: "universe"> => {
        let uni_lvl = &uni[4..]; // Skip "Type" prefix
        let level = if !uni_lvl.is_empty() {
            uni_lvl.parse::<u32>().expect("the number is always valid, because we used regex [0-9]*; qed")
        } else {
            0
        };
        Term::Universe(level)
    },
    <var: Ident> => Term::Var(var),
    "(" <Term> ")",
};

AppExpr : Term = {
    <l: AtomExpr> "->" <r: Term> => {
        term::arrow(l, r)
    },
    AtomExpr,
    <f: AtomExpr> <args: AtomExpr+> => {
        term::app_many(f, args)
    },
}

ForallParam : Vec<(Sym, BTerm)> = {
    "(" <idents: Ident+> ":" <ty : Term> ")" => idents.into_iter().map(|ident| (ident, box ty.clone())).collect()
}

ForallParams : Vec<(Sym, BTerm)> = {
    <ident: Ident> ":" <ty : Term> => vec![(ident, box ty)],
    <ForallParam+> => <>.into_iter().flatten().collect()
}

pub Term: Term = {
    "lam" <params: ForallParams> "=>" <body: Term> => {
        Term::lam_many(params, box body)
    },
    "forall" <params: ForallParams> "," <body: Term> => {
        Term::pi_many(params, box body)
    },
    AppExpr,
};

TypeParam: Param = {
    "(" <name: Ident> ":" <e: Term> ")" => Param::new(Some(name), e),
    <AtomExpr> => Param::new(None, <>),
}

Clause: Constructor = {
    "|" <name: Ident> <params: TypeParam*> => Constructor::new(name, params),
}

DataType: Term = {
    ":" <Term>
}


pub Decl: Decl = {
    "let" <name: Ident> ":=" <body: Term> => {
        Decl::Fn { name, ty: None, body }
    },
    "let" <name: Ident> ":" <ty: Term> "=>" <body: Term> => {
        Decl::Fn { name, ty: Some(ty), body }
    },
    "data" <name: Ident> <ty_params: TypeParam*> <ty: DataType?> <cons: Clause*> => {
       Decl::Data { name, ty_params, ty, cons }
    },
}

pub Prog : Vec<Decl> = {
    <Decl*>
}
