use crate::expr::{self, Kinds, Expr, Sym, BExpr};
use crate::item::{self, Item};

grammar;

Ident: Sym = <s:r"[a-zA-Z][a-zA-Z0-9]*"> => Sym::from(s);

AtomExpr: Expr = {
    "*" => Kinds::Star.into(),
    <var: Ident> => {
        Expr::Var(var)
    },
    "(" <Expr> ")",
};

AppExpr : Expr = {
    <l: AtomExpr> "->" <r: Expr> => {
        *expr::arrow(l, r)
    },
    AtomExpr,
    <f: AtomExpr> <args: AtomExpr+> => {
        *expr::app_many(f, args)
    },
}

ForallParam : Vec<(Sym, BExpr)> = {
    "(" <idents: Ident+> ":" <ty : Expr> ")" => idents.into_iter().map(|ident| (ident, box ty.clone())).collect()
}

ForallParams : Vec<(Sym, BExpr)> = {
    <ident: Ident> ":" <ty : Expr> => vec![(ident, box ty)],
    <ForallParam+> => <>.into_iter().flatten().collect()
}

pub Expr: Expr = {
    "lam" <params: ForallParams> "=>" <body: Expr> => {
        Expr::lam_many(params, box body)
    },
    "forall" <params: ForallParams> "," <body: Expr> => {
        Expr::pi_many(params, box body)
    },
    AppExpr,
};

pub Clause: (Sym, Option<Expr>) = {
    "|" <name: Ident> ":" <e: Expr> => (name, Some(e)),
    "|" <name: Ident> => (name, None)
}

DataType: Expr = {
    ":" <Expr>
}

TypeArg: (Option<Sym>, Expr) = {
    "(" <name: Ident> ":" <e: Expr> ")" => (Some(name), e),
    <AtomExpr> => (None, <>),
}

pub Item: Item = {
    "let" <name: Ident> "=>" <body: Expr> => {
        Item::Fn { name, ty: None, body }
    },
    "let" <name: Ident> ":" <ty: Expr> "=>" <body: Expr> => {
        Item::Fn { name, ty: Some(ty), body }
    },
    "data" <name: Ident> <ty_args: TypeArg*> <ty: DataType?> <cons: Clause*> => {
       Item::Data { name, ty_args, ty, cons }
    },
}

pub Prog : Vec<Item> = {
    <Item*>
}