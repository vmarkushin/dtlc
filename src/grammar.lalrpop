use crate::term::{self, Term, Sym, Param, Lam, Pi, App, Universe, Var};
use crate::decl::{self, Decl, Constructor, FnDecl};
use crate::token::Token;

grammar<'input>;

Ident: Var = <s:"ident"> => Var(Sym::from(s));

extern {
    enum Token<'input> {
        "ident" => Token::Ident(<&'input str>),
        "universe" => Token::Universe(<&'input str>),
        "goal" => Token::Goal(<&'input str>),
        "forall" => Token::Pi,
        "exists" => Token::Sigma,
        "data" => Token::Data,
        "codata" => Token::Codata,

        "@" => Token::At,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "=>" => Token::DArrow,
        ":=" => Token::Assignment,
        "lam" => Token::Lam,
        "fn" => Token::Let,
        "|" => Token::Pipe,
        "->" => Token::RArrow,
        "_" => Token::Hole,

        "{" => Token::LBrace,
        "[" => Token::LBracket,
        "(" => Token::LParen,

        "}" => Token::RBrace,
        "]" => Token::RBracket,
        ")" => Token::RParen,
    }
}

AtomExpr: Term = {
    <uni: "universe"> => {
        let uni_lvl = &uni[4..]; // Skip "Type" prefix
        let level = if !uni_lvl.is_empty() {
            uni_lvl.parse::<u32>().expect("the number is always valid, because we used regex [0-9]*; qed")
        } else {
            0
        };
        Term::Universe(Universe(level))
    },
    "_" => Term::Hole,
    <var: Ident> => Term::Var(var),
    "(" <Term> ")",
};

AppExpr : Term = {
    AtomExpr,
    <f: AtomExpr> <args: AtomExpr+> => App::new_many(f, args.into_iter()),
}

ForallParam : Vec<(Var, Term)> = {
    "(" <idents: Ident+> ":" <ty : Term> ")" => idents.into_iter().map(|ident| (ident, ty.clone())).collect()
}

LamParams : Vec<(Var, Term)> = {
    <ident: Ident> ":" <ty : Term> => vec![(ident, ty)],
    <ForallParam+> => <>.into_iter().flatten().collect()
}

Lam : Term = {
    "lam" <params: LamParams> "=>" <body: Term> => {
        Lam::new_many(body, params.into_iter()).into()
    },
}

ForallParams : Vec<(Var, Term)> = {
    <ForallParam+> => <>.into_iter().flatten().collect()
}

Pi : Term = {
    <l: AtomExpr> "->" <r: Term> => Pi::arrow(l, r).into(),
    "forall" <params: ForallParams> "," <body: Term> => {
        Pi::new_many(body, params.into_iter()).into()
    },
}

pub Term: Term = {
    Pi,
    Lam,
    AppExpr,
}

TypeParam: Param = {
    "(" <name: Ident> ":" <e: Term> ")" => Param::new(Some(name), e),
    <AtomExpr> => Param::new(None, <>),
}

Clause: Constructor = {
    "|" <name: Ident> <params: TypeParam*> => Constructor::new(name, params),
}

DataType: Term = {
    ":" <Term>
}

pub Decl: Decl = {
    "fn" <name: Ident> <params: TypeParam*> <ret_ty: DataType?> ":=" <body: Term> => {
       FnDecl { name, params: params.into(), ret_ty, body }.into()
    },
    "data" <name: Ident> <ty_params: TypeParam*> <universe: DataType?> <cons: Clause*> => {
       Decl::Data { name, ty_params: ty_params.into(), universe, cons }
    },
}

pub Prog : Vec<Decl> = {
    <Decl*>
}
