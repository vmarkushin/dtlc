use crate::expr::{self, Expr, Sym, BExpr};
use crate::item::{self, Item};
use crate::token::{Token};

grammar<'input>;

Ident: Sym = <s:"ident"> => Sym::from(s);

extern {
    enum Token<'input> {
        "ident" => Token::Ident(<&'input str>),
        "universe" => Token::Universe(<&'input str>),
        "forall" => Token::Pi,
        "exists" => Token::Sigma,
        "data" => Token::Data,
        "codata" => Token::Codata,

        "@" => Token::At,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "=>" => Token::DArrow,
        ":=" => Token::Assignment,
        "lam" => Token::Lam,
        "let" => Token::Let,
        "|" => Token::Pipe,
        "->" => Token::RArrow,

        "{" => Token::LBrace,
        "[" => Token::LBracket,
        "(" => Token::LParen,

        "}" => Token::RBrace,
        "]" => Token::RBracket,
        ")" => Token::RParen,
    }
}

AtomExpr: Expr = {
    <uni: "universe"> => {
        let uni_lvl = &uni[4..]; // Skip "Type" prefix
        let level = if !uni_lvl.is_empty() {
            uni_lvl.parse::<u32>().expect("the number is always valid, because we used regex [0-9]*; qed")
        } else {
            0
        };
        Expr::Universe(level)
    },
    <var: Ident> => Expr::Var(var),
    "(" <Expr> ")",
};

AppExpr : Expr = {
    <l: AtomExpr> "->" <r: Expr> => {
        *expr::arrow(l, r)
    },
    AtomExpr,
    <f: AtomExpr> <args: AtomExpr+> => {
        *expr::app_many(f, args)
    },
}

ForallParam : Vec<(Sym, BExpr)> = {
    "(" <idents: Ident+> ":" <ty : Expr> ")" => idents.into_iter().map(|ident| (ident, box ty.clone())).collect()
}

ForallParams : Vec<(Sym, BExpr)> = {
    <ident: Ident> ":" <ty : Expr> => vec![(ident, box ty)],
    <ForallParam+> => <>.into_iter().flatten().collect()
}

pub Expr: Expr = {
    "lam" <params: ForallParams> "=>" <body: Expr> => {
        Expr::lam_many(params, box body)
    },
    "forall" <params: ForallParams> "," <body: Expr> => {
        Expr::pi_many(params, box body)
    },
    AppExpr,
};

Clause: (Sym, Option<Expr>) = {
    "|" <name: Ident> ":" <e: Expr> => (name, Some(e)),
    "|" <name: Ident> => (name, None)
}

DataType: Expr = {
    ":" <Expr>
}

TypeParam: (Option<Sym>, Expr) = {
    "(" <name: Ident> ":" <e: Expr> ")" => (Some(name), e),
    <AtomExpr> => (None, <>),
}

pub Item: Item = {
    "let" <name: Ident> ":=" <body: Expr> => {
        Item::Fn { name, ty: None, body }
    },
    "let" <name: Ident> ":" <ty: Expr> "=>" <body: Expr> => {
        Item::Fn { name, ty: Some(ty), body }
    },
    "data" <name: Ident> <ty_params: TypeParam*> <ty: DataType?> <cons: Clause*> => {
       Item::Data { name, ty_params, ty, cons }
    },
}

pub Prog : Vec<Item> = {
    <Item*>
}
