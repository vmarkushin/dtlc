use crate::syntax::surf::{Expr, Decl, Param, Data, Func, NamedTele, Case, Pat, MetaAttr, Nat, Literal};
use crate::syntax::{Ident, Universe, Loc, Plicitness::*};
use crate::token::{Token, Position};
use vec1::Vec1;

grammar<'input>;

extern {
    type Location = Position;

    enum Token<'input> {
        "ident" => Token::Ident(<String>),
        "universe" => Token::Universe(<&'input str>),
        "metaident" => Token::MetaIdent(String),
        "nat" => Token::Nat(<&'input str>),
        "string" => Token::Str(<&'input str>),
        "forall" => Token::Pi,
//        "exists" => Token::Sigma,
        "data" => Token::Data,
        "codata" => Token::Codata,
        "match" => Token::Match,

        "@" => Token::At,
        "#" => Token::Hash,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "=>" => Token::DArrow,
        ":=" => Token::Assignment,
//        "=" => Token::MetaAssignment,
        "lam" => Token::Lam,
        "fn" => Token::Fn,
        "let" => Token::Let,
        "|" => Token::Pipe,
        "->" => Token::RArrow,
        "_" => Token::Underscore,
        "!" => Token::Bang,
        "?" => Token::Question,

        "{" => Token::LBrace,
        "[" => Token::LBracket,
        "(" => Token::LParen,

        "}" => Token::RBrace,
        "]" => Token::RBracket,
        ")" => Token::RParen,
    }
}

SepAny<Rule, Delim>: Vec<Rule> =
    <rules: (<Rule> Delim)*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

SepMany<Rule, Delim>: Vec1<Rule> =
    <rules: (<Rule> Delim)*> <last: Rule> => {
        let mut rules = rules;
        rules.push(last);
        Vec1::try_from_vec(rules).unwrap()
    };

#[inline]
Sp<Rule>: (Rule, Loc) =
    <l: @L> <rule: Rule> <r: @R> => (rule, Loc::new2(l, r));

#[inline]
Sp_<Rule>: Loc =
    <sp: Sp<Rule>> => match sp { (_, loc) => loc };

Ident: Ident = <t : Sp<"ident">> => Ident::new(t.0, t.1);

Universe: Universe =
    <uni: "universe"> => {
        let uni_lvl = &uni[4..]; // Skip "Type" prefix
        let level = if !uni_lvl.is_empty() {
            uni_lvl.parse::<u32>().expect("the number is always valid, because we used regex [0-9]*; qed")
        } else {
            0
        };
        Universe(level)
    };

Str : String = {
    <str: "string"> => str[1..str.len() - 1].to_string(),
}

Nat : Nat = {
    <nat: "nat"> => nat.parse::<Nat>().expect("the number is always valid, because we used regex [0-9]*; qed"),
}

Literal : Literal = {
    <Str> => Literal::Str(<>),
    <Nat> => Literal::Nat(<>),
}

PrimExpr: Expr = {
    <uni: Sp<Universe>> => {
        let (uni, loc) = uni;
        Expr::Universe(loc, uni)
    },
    Sp_<"_"> => Expr::Hole(<>),
    Sp_<"metaident"> => Expr::Hole(<>),
    <var: Ident> => Expr::Var(var),
    Sp<Literal> => Expr::Lit(<>.1, <>.0),
    Tuple,
    "(" <Expr> ")",
};

//Arg : Expr = {
//    <var: Ident> => Expr::Var(var),
//    "(" <Expr> ")",
//}

AppExpr : Expr = {
    PrimExpr,
    <f: PrimExpr> <args: PrimExpr+> => Expr::App(Box::new(f), Vec1::try_from_vec(args).unwrap()),
}

ForallParam : Vec1<Param> = {
    "(" <idents: Ident+> ":" <ty : Expr> ")" => Vec1::try_from_vec(idents.into_iter().map(|ident| Param::new(ident, ty.clone(), Explicit)).collect()).unwrap()
}

LamParam : Vec1<Param> = {
    <ident: Ident> => Vec1::new(Param::from_ident(ident, Explicit)),
    "(" <idents: Ident+> ":" <ty : Expr> ")" => Vec1::try_from_vec(idents.into_iter().map(|ident| Param::new(ident, ty.clone(), Explicit)).collect()).unwrap(),
    "{" <idents: Ident+> ":" <ty : Expr> "}" => Vec1::try_from_vec(idents.into_iter().map(|ident| Param::new(ident, ty.clone(), Implicit)).collect()).unwrap(),
}

LamParams : Vec1<Param> = {
    <ident: Ident> ":" <ty : Expr> => Vec1::new(Param::new(ident, ty, Explicit)),
    <LamParam+> => Vec1::try_from_vec(<>.into_iter().flatten().collect()).unwrap()
}

Lam : Expr = {
    "lam" <params: LamParams> "=>" <body: Expr> => {
        Expr::Lam(params, box body)
    },
}

ForallParams : Vec1<Param> = {
    <ForallParam+> => Vec1::try_from_vec(<>.into_iter().flatten().collect()).unwrap()
}

Pi : Expr = {
    <l: PrimExpr> "->" <r: Expr> => Expr::Pi(Vec1::new(Param::from_type(l, Explicit)), Box::new(r)),
    "forall" <params: ForallParams> "," <body: Expr> => {
        Expr::Pi(params, Box::new(body))
    },
}

Pattern : Pat = {
    Sp_<"_"> => Pat::Wildcard,
    <var: Ident> => Pat::Var(var),
    "(" <dot: "."?> <con: Ident> <args: Pattern+> ")" => Pat::cons_surf(dot.is_some(), con, args),
    "." <e: PrimExpr>  => Pat::Forced(e),
    "!" => Pat::Absurd,
}

Tuple : Expr = {
//    <loc: Sp_<"(">> <e: SepAny<PrimExpr, ",">> ")" => Expr::Tuple(loc, e),
    <loc: Sp_<"(">> <e: (<PrimExpr> ",")*> ")" => Expr::Tuple(loc, e),
}

Case : Case = {
    "|" <pats: SepAny<Pattern, ",">> <body: ("=>" <Expr>)?> => Case::new(pats, body),
}

Match : Expr = {
    "match" <exprs: SepMany<Expr, ",">> "{" <cases: Case*> "}" => Expr::Match(exprs, cases),
}

pub Expr: Expr = {
    Pi,
    Lam,
    Match,
    AppExpr,
}

MetaAttrApp : MetaAttr = {
    <Ident> => MetaAttr::Ident(<>),
    <f: Ident> <args: PrimMetaAttr+> => MetaAttr::App(f, Vec1::try_from_vec(args).unwrap()),
}

MetaField : (Ident, String) = {
    <name: Ident> ":=" <value: Str> => (name, value),
}

PrimMetaAttr : MetaAttr = {
    <ident: Ident> => MetaAttr::Ident(ident),
    <field: MetaField> => MetaAttr::Struct(Vec1::new(field)),
    "(" <MetaAttrApp> ")",
    "{" <fields: SepMany<MetaField, ",">> "}" => MetaAttr::Struct(fields),
}

MetaAttribute : MetaAttr = {
    "#" "(" <PrimMetaAttr> ")",
}

TypeParam: Param = {
    "(" <name: Ident> ":" <e: Expr> ")" => Param::new(name, e, Explicit),
    "{" <name: Ident> ":" <e: Expr> "}" => Param::new(name, e, Implicit),
    <PrimExpr> => Param::from_type(<>, Explicit),
}

FnType: Expr = {
    ":" <Expr>
}

Constructor: NamedTele = {
    "|" <name: Ident> <params: TypeParam*> => NamedTele::new(name, params.into()),
}

DataType: Universe = {
    ":" <Universe>
}

pub Decl: Decl = {
    <meta_attrs: MetaAttribute*> "fn" <name: Ident> <params: TypeParam*> <ret_ty: FnType?> ":=" <body: Expr> => {
       Func { name, params: params.into(), ret_ty, body, meta_attrs }.into()
    },
    <meta_attrs: MetaAttribute*> "data" <name: Ident> <ty_params: TypeParam*> <universe: DataType?> <cons: Constructor*> => {
      Data { sig: NamedTele::new(name, ty_params.into()), universe, cons, meta_attrs }.into()
    },
}

pub Prog : Vec<Decl> = <Decl*>;
